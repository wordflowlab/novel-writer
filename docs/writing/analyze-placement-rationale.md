# Analyze 命令位置差异的设计论证

## 问题背景

社区用户反馈：**spec-kit 和 novel-write 中 analyze 命令的位置不一致**

- spec-kit (代码开发): analyze 在 implement **之前**
- novel-write (小说创作): analyze 在 write **之后**

这是设计错误还是有意为之？本文档将深入论证这一差异的合理性。

## 流程对比

### spec-kit (软件开发) 的标准流程

```
constitution → specify → clarify → plan → tasks → analyze → implement
                                                      ↑
                                           在实现之前进行验证
```

来源：[spec-kit README.md L216](https://github.com/github/spec-kit)

```markdown
| `/analyze` | Cross-artifact consistency & coverage analysis
             (run after /tasks, before /implement) |
```

**analyze 的作用**：
- 交叉验证规格、计划、任务之间的一致性
- 检查覆盖率（所有需求是否都有对应的任务）
- 发现矛盾和遗漏（在编码前修复）
- 确保实现前准备充分

### novel-write (小说创作) 的标准流程

```
constitution → specify → clarify → plan → tasks → write → analyze
                                                             ↑
                                              在写作之后进行验证
```

来源：[novel-write templates/commands/write.md L115](../../templates/commands/write.md)

```markdown
/constitution → 提供创作原则
     ↓
/specify → 定义故事需求
     ↓
/clarify → 澄清关键决策
     ↓
/plan → 制定技术方案
     ↓
/tasks → 分解执行任务
     ↓
/write → 【当前】执行写作
     ↓
/analyze → 验证质量一致
```

**analyze 的作用**：
- 验证已完成内容是否符合规格书
- 检查情节连贯性、角色一致性
- 评估质量标准达成情况
- 生成改进建议

## 核心差异分析

### 差异 1：验证的对象不同

| 维度 | spec-kit (代码) | novel-write (小说) |
|------|----------------|-------------------|
| **验证对象** | 规格文档、计划、任务清单 | 已创作的内容 |
| **验证内容** | 一致性、完整性、可实现性 | 质量、连贯性、主题表达 |
| **验证时机** | 实现前（预防性） | 创作后（评估性） |

### 差异 2：错误成本不同

**代码开发的错误成本**：
- ❌ 如果不在实现前 analyze，可能写了 50% 代码才发现设计矛盾
- ❌ 重构成本高，已写的代码可能作废
- ✅ 预先验证可以避免返工

**小说创作的错误成本**：
- ✅ 如果在写作前过度分析，会打断创作灵感
- ✅ 先完成初稿，再批量修改是更高效的流程
- ✅ 文学作品允许在修订中完善

### 差异 3：反馈循环的性质

**代码开发（预防型反馈）**：
```
plan → tasks → analyze → 发现矛盾 → 修改 plan/tasks → implement
          ↑_______________|
        （无代码损失）
```

**小说创作（迭代型反馈）**：
```
plan → tasks → write → analyze → 发现问题 → 修订内容
                  ↑_______________________|
              （内容已存在，精修而非重写）
```

## 设计合理性论证

### 为什么代码需要 "analyze before implement"？

#### 1. **即时可修改性**
- 规格、计划、任务都是文档，修改成本低
- analyze 发现问题后，调整文档即可
- 实现前的调整不会浪费代码工作量

#### 2. **二元正确性**
- 代码要么能编译，要么不能
- 测试要么通过，要么失败
- analyze 可以提前发现这些二元问题

#### 3. **依赖复杂性**
- 代码模块之间有强依赖关系
- 一旦开始实现，依赖树就确定了
- 提前 analyze 可以优化依赖结构

#### 4. **工具化验证**
- analyze 可以自动检查：
  - 所有 spec 需求是否有对应的 task
  - tasks 是否覆盖 plan 中的所有组件
  - contracts 是否与 data-model 一致
- 这些检查不需要实际代码

**实例：spec-kit 的 analyze 检查项**
```markdown
## Coverage Analysis
- [ ] All P0 requirements have corresponding tasks
- [ ] All entities in data-model.md have CRUD tasks
- [ ] All API endpoints in contracts/ have implementation tasks

## Consistency Analysis
- [ ] Plan's tech stack matches tasks' tooling
- [ ] No contradictions between spec.md and plan.md
- [ ] Test tasks exist before implementation tasks (TDD)
```

### 为什么小说需要 "write before analyze"？

#### 1. **创作心流保护**
- 写作需要连续的创意状态（flow state）
- 频繁打断会破坏叙事节奏和灵感
- 先完成初稿，再批量分析更符合创作心理

#### 2. **质量的连续性**
- 文学质量不是二元的（不是"对/错"）
- 需要评分、分析维度（1-10分）
- 必须有实际内容才能评判质量

#### 3. **上下文依赖**
- 单个章节无法验证主题、节奏、人物弧
- 需要累积到一定量（5-10章）才能深度分析
- 批量验证比逐章验证更有效

#### 4. **迭代完善模式**
- 小说创作本质是"草稿 → 修订 → 精修"
- 初稿允许不完美，在 analyze 后调整
- 这种模式与代码的"测试先行"本质不同

**实例：novel-write 的 analyze 检查项**
```markdown
## 宪法合规性检查
- [ ] 是否符合核心价值观
- [ ] 是否达到质量标准

## 规格符合度分析
- [ ] P0 必需元素是否已实现
- [ ] 目标读者适配度评分

## 内容质量分析
- [ ] 情节密度评分
- [ ] 人物一致性检查
- [ ] 节奏变化分析
```

## 工程 vs 艺术：本质差异

### 维度对比表

| 维度 | 代码开发 (工程) | 小说创作 (艺术) |
|------|----------------|----------------|
| **正确性标准** | 二元（通过/失败） | 连续谱（1-10分） |
| **验证时机** | 预防性（事前） | 评估性（事后） |
| **修改成本** | 实现后高，实现前低 | 初稿后可接受 |
| **工作流特征** | 可打断、可并行 | 需保持连续性 |
| **反馈机制** | 自动化工具验证 | 人工+AI 综合判断 |
| **验证粒度** | 细粒度（函数级） | 粗粒度（章节/卷级） |
| **完美时机** | 第一次就要对 | 迭代中逐步完善 |

### 心理学差异

**工程师的工作模式**：
- 先设计架构（可以反复推敲）
- 确认无误后再编码
- 编码中遇到问题就是设计缺陷

**作家的工作模式**：
- 先快速记录灵感（不要被理性打断）
- 完成初稿后再审视全局
- 修改是创作过程的必要部分

### 历史经验验证

**软件工程的最佳实践**：
- TDD (测试驱动开发): 先写测试再写代码
- Design Review: 实现前审查设计
- Architecture Review: 编码前验证架构
- **结论**：事前验证已被业界验证为最佳实践

**文学创作的最佳实践**：
- 海明威："初稿都是狗屎"（先完成，再完美）
- Stephen King: 先写完整故事，关6周后再修改
- 写作工作坊的标准流程：Draft → Critique → Revise
- **结论**：事后修改是创作的标准流程

## 如果反过来会怎样？

### 假设 1：代码也采用 "implement before analyze"

```
plan → tasks → implement → analyze → 发现问题
                    ↓
                写了 5000 行代码
                    ↓
            analyze 发现架构有矛盾
                    ↓
            需要重构或重写 ❌
```

**问题**：
- 浪费了大量编码时间
- 可能已有技术债务累积
- 团队士气受挫

### 假设 2：小说也采用 "analyze before write"

```
plan → tasks → analyze (检查计划) → write
                ↑
        检查什么？没有内容啊！
```

**问题**：
- analyze 无法检查尚不存在的内容
- 只能检查计划的逻辑性，但这在 clarify 阶段已完成
- 过度分析会导致"完美主义瘫痪"，永远写不出初稿

## 实际使用场景

### spec-kit 的 analyze 使用场景

**时机**：完成 tasks.md 后，实施 implement 前

**典型对话**：
```
User: /tasks
AI: 已生成任务清单，包含 23 个任务

User: /analyze
AI:
分析完成！

【覆盖率分析】
✅ 所有 P0 需求都有对应任务
⚠️  规格中的"用户通知"功能没有对应的 task
❌ data-model.md 中的 Comment 实体缺少 CRUD 任务

【一致性分析】
✅ Plan 使用 PostgreSQL，tasks 正确配置数据库
❌ Spec 要求"实时更新"，但 plan 中没有 WebSocket

建议：
1. 添加通知功能的 3 个任务
2. 添加 Comment CRUD 的 4 个任务
3. 在 plan 中补充 WebSocket 方案

修复这些问题后再运行 /implement
```

### novel-write 的 analyze 使用场景

**时机**：完成 5-10 章后，或完成一卷后

**典型对话**：
```
User: /write (完成第 1-5 章)

User: /analyze
AI:
综合分析报告

【宪法合规性】8/10
✅ 符合核心价值观
⚠️ 第 3 章节奏略慢，可能影响读者留存

【规格符合度】7/10
✅ P0 元素"父子冲突"已充分展现
❌ P0 元素"悬念设置"不足，第 5 章应有转折点

【内容质量】
- 情节密度：中等
- 人物一致性：主角在第 2 章和第 4 章对同一事件反应矛盾
- 节奏：前 3 章慢，第 4-5 章加速合理

【改进建议】
P0（紧急）：
1. 修复主角的性格矛盾（第 2 章 vs 第 4 章）
2. 在第 5 章结尾增加悬念设置

P1（优化）：
1. 第 3 章可压缩 20%，提升节奏
```

## 结论

### analyze 位置差异是正确的设计

| 项目 | 命令位置 | 原因 |
|-----|---------|------|
| **spec-kit** | tasks → **analyze** → implement | 预防性验证，降低实现成本 |
| **novel-write** | tasks → write → **analyze** | 评估性验证，保护创作心流 |

### 设计原则

**工程活动**（代码）：
- 遵循"Measure twice, cut once"（三思而后行）
- 事前验证可以避免返工
- analyze 在 implement 前

**艺术活动**（小说）：
- 遵循"Done is better than perfect"（完成胜于完美）
- 初稿允许不完美，精修在后期
- analyze 在 write 后

### 统一的方法论哲学

尽管 analyze 位置不同，但两者都遵循 **Specification-Driven Development** 的核心理念：

```
Specification (what) → Plan (how) → Execute (do) → Verify (check)
```

差异在于 **Verify 的时机**：
- 代码：在 Execute 前 verify（预防）
- 小说：在 Execute 后 verify（评估）

这种差异体现了 **SDD 方法论的灵活性**：同样的思想框架，根据领域特性调整实施细节。

### 给使用者的建议

**使用 spec-kit 开发软件时**：
- ✅ 务必在 implement 前运行 analyze
- ✅ 根据 analyze 报告修改 plan/tasks
- ✅ 直到 analyze 通过所有检查再开始编码

**使用 novel-write 创作小说时**：
- ✅ 专注写作，不要在写作过程中频繁分析
- ✅ 累积一定量（5-10 章或一卷）后运行 analyze
- ✅ 根据 analyze 报告进行批量修订

---

**最后总结**：这不是设计错误，而是**领域驱动的合理差异**。代码需要"事前诸葛亮"，小说需要"事后诸葛亮"。

---

## 附录：智能双模式设计（v0.12.0 新增）

### 问题：两种需求都合理

经过社区讨论，我们发现两种 analyze 需求都有价值：

1. **write 之前的框架分析**（曾喜胜的建议）
   - 验证规格、计划、任务的一致性
   - 确保准备充分再开始写作
   - 避免写到一半发现设计问题

2. **write 之后的内容分析**（原有设计）
   - 验证已完成内容的质量
   - 检查是否符合规格
   - 提供改进建议

### 解决方案：一个命令，双重智能

秉承**克制原则**（避免命令爆炸），我们实现了**智能双模式 analyze**：

```bash
/analyze  # 自动判断应该执行哪种分析
```

### 智能检测逻辑

系统自动检测当前创作阶段，决定执行哪种分析：

```
章节数 = 0     → 框架分析（准备阶段）
章节数 < 3     → 框架分析（建议继续写作）
章节数 ≥ 3     → 内容分析（质量验证）
```

### 手动控制模式

支持用户明确指定分析类型：

```bash
/analyze --type=framework  # 强制框架分析
/analyze --type=content    # 强制内容分析
```

### 两种分析模式对比

| 维度 | 框架分析 | 内容分析 |
|------|---------|---------|
| **执行时机** | write 之前 | write 之后 |
| **分析对象** | 规格/计划/任务文档 | 已完成的章节内容 |
| **核心目标** | 验证准备就绪 | 验证质量达标 |
| **检查项** | 覆盖率、一致性、逻辑预警 | 宪法合规、规格符合、内容质量 |
| **输出建议** | 修复文档矛盾、补充缺失任务 | 修复内容问题、优化章节质量 |

### 实际使用示例

#### 示例1：准备写作阶段

```bash
用户：/tasks
AI：已生成 28 个写作任务

用户：/analyze
AI：检测到无章节内容，执行框架一致性分析...

【覆盖率分析】
⚠️ 规格需求"反派设定"无对应任务
❌ 计划第10-12章缺少任务分解

【准备评分】6/10
建议：修复上述问题后再开始写作
```

#### 示例2：完成若干章节后

```bash
用户：/write（完成第1-7章）

用户：/analyze
AI：检测到已完成 7 章，执行内容质量分析...

【宪法合规】8/10 ✅
【规格符合】7/10 ⚠️ P0需求覆盖67%
【内容质量】7.5/10 ⚠️ 有2处逻辑问题

【改进建议】
P0：修复时间线矛盾、角色能力矛盾
P1：第5章增加悬念

【建议】：修复P0问题后，继续创作第8-10章
```

### 设计哲学

**克制而不简陋**：
- ❌ 不创建 `/framework-analyze` 和 `/content-analyze` 两个命令
- ✅ 一个 `/analyze` 命令，智能判断场景
- ✅ 支持手动指定模式（高级用户）
- ✅ 90% 的场景自动处理，10% 可手动控制

**微信的克制原则**：
- 功能强大，但命令简洁
- 系统智能，用户无负担
- 高级功能隐藏，不干扰常规使用

### 技术实现

详见 `templates/commands/analyze.md` 和 `scripts/bash/check-analyze-stage.sh`

---

**总结**：智能双模式设计既满足了两种分析需求，又保持了命令的简洁性。这是**克制原则**和**用户需求**完美平衡的典范。
